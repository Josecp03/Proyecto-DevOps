# ‚öôÔ∏è Paso 4 - Ansible (Automatizaci√≥n de despliegues)

Ansible es una herramienta de automatizaci√≥n que permite gestionar configuraciones y desplegar servicios de forma sencilla mediante ficheros declarativos. En este proyecto lo utilizo para preparar la m√°quina de copias de seguridad y la m√°quina de base de datos, asegurando que ambas tengan la configuraci√≥n necesaria sin tener que hacerlo manualmente en cada servidor.

## üìã Tabla de contenidos
- [‚öôÔ∏è Paso 4 - Ansible (Automatizaci√≥n de despliegues)](#Ô∏è-paso-4---ansible-automatizaci√≥n-de-despliegues)
  - [üìã Tabla de contenidos](#-tabla-de-contenidos)
  - [üíª 4.1 Instalaci√≥n Ansible](#-41-instalaci√≥n-ansible)
  - [üîë 4.2 Comprobaci√≥n de acceso a las m√°quinas](#-42-comprobaci√≥n-de-acceso-a-las-m√°quinas)
  - [üõ†Ô∏è 4.3 Tareas a automatizar con Ansible](#Ô∏è-43-tareas-a-automatizar-con-ansible)
  - [üìÇ 4.4 Estructura de archivos](#-44-estructura-de-archivos)
  - [üìÇ 4.5 Archivos de Ansible](#-45-archivos-de-ansible)
    - [üöÄ 4.5.1 Archivos ra√≠z](#-451-archivos-ra√≠z)
      - [`ansible.cfg`](#ansiblecfg)
      - [`requeriments.yml`](#requerimentsyml)
    - [üóÇÔ∏è 4.5.2 Inventories](#Ô∏è-452-inventories)
      - [`inventories/dev/inventory.ini`](#inventoriesdevinventoryini)
      - [`inventories/dev/group_vars/all.yml`](#inventoriesdevgroup_varsallyml)
      - [`inventories/dev/group_vars/backups.yml`](#inventoriesdevgroup_varsbackupsyml)
      - [`inventories/dev/group_vars/database.yml`](#inventoriesdevgroup_varsdatabaseyml)
      - [`inventories/dev/group_vars/vault.yml`](#inventoriesdevgroup_varsvaultyml)
    - [üìú 4.5.2 Playbooks](#-452-playbooks)
      - [`playbooks/bkp.yml`](#playbooksbkpyml)
      - [`playbooks/db.yml`](#playbooksdbyml)
      - [`playbooks/dr.yml`](#playbooksdryml)
    - [üë§ 4.5.3 roles](#-453-roles)
      - [`roles/backup/tasks/main.yml`](#rolesbackuptasksmainyml)
      - [`roles/dr_test/tasks/main.yml`](#rolesdr_testtasksmainyml)
      - [`roles/mysql/tasks/main.yml`](#rolesmysqltasksmainyml)
      - [`roles/mysql/templates/mysqld.conf.j2`](#rolesmysqltemplatesmysqldconfj2)
      - [`roles/mysql/handlers/main.yml`](#rolesmysqlhandlersmainyml)
  - [‚öôÔ∏è 4.6 Preparaci√≥n entorno Ansible](#Ô∏è-46-preparaci√≥n-entorno-ansible)
  - [üöÄ 4.7 Lanzar playbooks](#-47-lanzar-playbooks)
    - [‚úÖ 4.7.1 Probar conexi√≥n](#-471-probar-conexi√≥n)
    - [üõ†Ô∏è 4.7.2 Configuraci√≥n de MySQL en la VM de base de datos](#Ô∏è-472-configuraci√≥n-de-mysql-en-la-vm-de-base-de-datos)
    - [üíæ 4.7.2 Automatizaci√≥n de backups de la BBDD](#-472-automatizaci√≥n-de-backups-de-la-bbdd)
    - [üîÑ 4.7.3 Automatizaci√≥n de backups de la BBDD](#-473-automatizaci√≥n-de-backups-de-la-bbdd)

---

## üíª 4.1 Instalaci√≥n Ansible

A continuaci√≥n voy a detallar el proceso de instalaci√≥n de Ansible Core en la versi√≥n 2.17.8. He decidido usar esta versi√≥n concreta porque, tras varias pruebas, es la que mejor se adapta a mi infraestructura con Terraform y evita problemas al conectarme a las m√°quinas y ejecutar tareas. Para la instalaci√≥n se utiliza Python3 junto con pip, que es el gestor de paquetes de Python y permite instalar Ansible de forma sencilla en el entorno del usuario. Adem√°s, es necesario a√±adir la carpeta local al PATH para que el sistema pueda reconocer y ejecutar los comandos de Ansible desde cualquier ubicaci√≥n. De esta manera, la herramienta quedar√° correctamente configurada y lista para usarse.

* Primero actualizamos el sistema:

    ```bash
    sudo apt update && sudo apt upgrade -y
    ```

* Despu√©s instalamos Python3, pip y dependencias necesarias:

    ```bash
    sudo apt install -y python3 python3-pip python3-venv
    ```

* Instalamos Ansible Core en la versi√≥n 2.17.:

    ```bash
    python3 -m pip install --user ansible-core==2.17.8
    ```

* A√±adimos la ruta local al PATH:

    ```bash     
    echo 'export PATH=$HOME/.local/bin:$PATH' >> ~/.bashrc
    source ~/.bashrc
    ```

* Verificamos la instalaci√≥n:

    ```bash
    ansible --version
    ```

---

## üîë 4.2 Comprobaci√≥n de acceso a las m√°quinas

Antes de comenzar a trabajar con Ansible, es fundamental asegurarse de que podemos acceder correctamente a las m√°quinas mediante SSH, ya que esta es la forma en la que Ansible se comunica con ellas para ejecutar tareas. En este caso, el acceso va a ser muy sencillo gracias al script generado previamente con Terraform, que ya deja configuradas las claves y par√°metros necesarios.

* Para acceder a la m√°quina del backup bastar√≠a con ejecutar el siguiente comando:

    ```bash
    ssh vm-bkp
    ```

* Para la de la base de datos mas de lo mismo:

    ```bash
    ssh vm-db
    ```

> El archivo encargado de que podamos realizar esta tarea de forma tan secilla se encuentra en `~/.ssh/config`

> ‚ö†Ô∏è **Advertencia:** Si ya se ha usado una m√°quina y luego se ha eliminado o recreado, es posible que quede almacenada la configuraci√≥n SSH anterior en tu equipo. Para evitar errores de conexi√≥n, ejecuta el siguiente comando antes de volver a conectarte:  
> 
> ```bash
> ssh-keygen -f "/home/user/.ssh/known_hosts" -R "10.0.2.4"
> ```

---

## üõ†Ô∏è 4.3 Tareas a automatizar con Ansible

En esta secci√≥n voy a explicar c√≥mo utilizar Ansible para automatizar tareas sobre las m√°quinas desplegadas con Terraform. El objetivo es simplificar y estandarizar la configuraci√≥n y operaci√≥n de los servidores, evitando tener que realizar cada paso de forma manual. Con Ansible se van a ejecutar tres tareas principales:

  1. Preparaci√≥n de la m√°quina de base de datos: instalaci√≥n y configuraci√≥n completa de MySQL, dejando el servidor listo para su uso.

  2. Preparaci√≥n de la m√°quina de backup: instalaci√≥n de las herramientas necesarias y configuraci√≥n de un script automatizado que realice copias de seguridad diarias a las 2:00 de la ma√±ana.

  3. Recuperaci√≥n desde backup: restauraci√≥n de la base de datos utilizando el archivo de backup previamente subido, permitiendo recuperar los datos de forma r√°pida y segura.

Estas tareas permiten garantizar que tanto la base de datos como el sistema de backup est√©n siempre operativos y preparados para cualquier eventualidad.

[üîù Volver a la tabla de contenidos üîù](#-tabla-de-contenidos) 

---

## üìÇ 4.4 Estructura de archivos

A continuaci√≥n se explicar√° la estructura y el contenido de los archivos de Ansible que se van a utilizar en el proyecto. Se detallar√° c√≥mo est√°n organizados los playbooks, roles y archivos de configuraci√≥n.

```
ansible/
‚îú‚îÄ‚îÄ ansible.cfg                        ‚Üê Configuraci√≥n global de Ansible
‚îú‚îÄ‚îÄ requirements.yml                   ‚Üê Roles externos o dependencias
‚îú‚îÄ‚îÄ inventories/
‚îÇ   ‚îî‚îÄ‚îÄ dev/
‚îÇ       ‚îú‚îÄ‚îÄ group_vars/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ all.yml                 ‚Üê Variables globales
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ backups.yml             ‚Üê Variables relacionadas con backups
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ database.yml            ‚Üê Variables relacionadas con base de datos
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ vault.yml               ‚Üê Variables sensibles
‚îÇ       ‚îî‚îÄ‚îÄ inventory.ini               ‚Üê Definici√≥n de hosts y grupos
‚îú‚îÄ‚îÄ playbooks/
‚îÇ   ‚îú‚îÄ‚îÄ bkp.yml                         ‚Üê Playbook para backups
‚îÇ   ‚îú‚îÄ‚îÄ db.yml                          ‚Üê Playbook para base de datos
‚îÇ   ‚îî‚îÄ‚îÄ dr.yml                          ‚Üê Playbook para disaster recovery
‚îî‚îÄ‚îÄ roles/
    ‚îú‚îÄ‚îÄ backup/
    ‚îÇ   ‚îî‚îÄ‚îÄ tasks/
    ‚îÇ       ‚îî‚îÄ‚îÄ main.yml                ‚Üê Tareas de backup
    ‚îú‚îÄ‚îÄ dr_test/
    ‚îÇ   ‚îî‚îÄ‚îÄ tasks/
    ‚îÇ       ‚îî‚îÄ‚îÄ main.yml                ‚Üê Tareas de DR test
    ‚îî‚îÄ‚îÄ mysql/
        ‚îú‚îÄ‚îÄ handlers/
        ‚îÇ   ‚îî‚îÄ‚îÄ main.yml                ‚Üê Handlers (reinicios, notificaciones, etc.)
        ‚îú‚îÄ‚îÄ tasks/
        ‚îÇ   ‚îî‚îÄ‚îÄ main.yml                ‚Üê Tareas de configuraci√≥n y gesti√≥n de MySQL
        ‚îî‚îÄ‚îÄ templates/
            ‚îî‚îÄ‚îÄ mysqld.cnf.j2           ‚Üê Plantilla del archivo de configuraci√≥n de MySQL
```

> Actualmente solo tenemos el entorno de desarrollo, y todas las variables necesarias para las m√°quinas creadas en ese entorno est√°n en inventories/dev/, incluyendo las generales, de backups, de base de datos y las sensibles cifradas con Vault. En el futuro, si se a√±adieran m√°s entornos, se crear√≠an carpetas y archivos de variables similares para cada uno, sin necesidad de cambiar los playbooks o roles existentes.

---

## üìÇ 4.5 Archivos de Ansible

A continuaci√≥n se muestran todos los archivos de Ansible que forman parte del proyecto, incluyendo playbooks, roles y archivos de configuraci√≥n, respetando la jerarqu√≠a de carpetas y la organizaci√≥n por entornos.

### üöÄ 4.5.1 Archivos ra√≠z

#### `ansible.cfg` 

Configura los valores por defecto de Ansible, como el inventario, usuario remoto, clave SSH y ruta de roles.

```ini
[defaults]
inventory = inventories/inventory.ini
host_key_checking = False
remote_user = josecp03
private_key_file = ~/.ssh/id_rsa
roles_path = ./roles
```

---

#### `requeriments.yml`

Lista las colecciones externas de Ansible que se necesitan.

```yml
collections:
  - name: community.mysql
```

---

### üóÇÔ∏è 4.5.2 Inventories

#### `inventories/dev/inventory.ini`

Define los hosts del entorno de desarrollo y los agrupa en all, database y backups seg√∫n su funci√≥n.

```ini
[all]
vm-bkp
vm-db

[database]
vm-db

[backups]
vm-bkp
```


#### `inventories/dev/group_vars/all.yml`

Define las variables globales no sensibles para el entorno de desarrollo

```yml
azure_container: "backups"
azure_storage_account: "stajosecp03devops"
db_user: employee_app_user
db_name: employee_management_system
```

---

#### `inventories/dev/group_vars/backups.yml`

Define las variables relacionadas con los backups

```yml
backup_dir: /tmp/db_backups
```

---

#### `inventories/dev/group_vars/database.yml`

Define las variables relacionadas con la base de datos

```yml
mysql_bind_address: "0.0.0.0"
backend_subnet: 10.0.2.0/24
restore_dir: /tmp/db_restore
```

---

#### `inventories/dev/group_vars/vault.yml`

Define las variables relacionadas con la base de datos

```yml
azure_storage_key: "1QYZ..."
db_password: dbpassword
backup_password: "backupassword"
```
> [azure_storage_key](#Ô∏è-46-preparaci√≥n-entorno-ansible) ‚¨ÖÔ∏è C√≥mo obtener la clave 

[üîù Volver a la tabla de contenidos üîù](#-tabla-de-contenidos) 

---

### üìú 4.5.2 Playbooks

#### `playbooks/bkp.yml`

Ejecuta el rol de backup en la m√°quina de backups

```yml
- name: Automatizaci√≥n de backups de la BBDD
  hosts: vm-bkp
  become: true
  vars_files:
    - ../inventories/dev/group_vars/vault.yml
  roles:
    - backup
```

---

#### `playbooks/db.yml`

Ejecuta el rol de configuraci√≥n de MySQL en la m√°quina de base de datos

```yml
- name: Configuraci√≥n de MySQL en la VM de base de datos
  hosts: vm-db
  become: true
  vars_files:
    - ../inventories/dev/group_vars/vault.yml
  roles:
    - mysql
```

---

#### `playbooks/dr.yml`

Ejecuta el rol de pruebas de Disaster Recovery en la m√°quina de base de datos

```yml
- name: Pruebas de Disaster Recovery
  hosts: vm-db
  become: true
  vars_files:
    - ../inventories/dev/group_vars/vault.yml
  roles:
    - dr_test
```

[üîù Volver a la tabla de contenidos üîù](#-tabla-de-contenidos) 

---

### üë§ 4.5.3 roles

#### `roles/backup/tasks/main.yml`

Crea el directorio de backups, instala Azure CLI, genera un script de backup cifrado de la base de datos, lo sube a Azure y programa su ejecuci√≥n diaria mediante cron, verificando que se haya configurado correctamente.

```yml
- name: Crear directorio de backups si no existe
  file:
    path: "{{ backup_dir }}"
    state: directory
    mode: '0755'

- name: Instalar Azure CLI desde el repositorio oficial
  shell: curl -sL https://aka.ms/InstallAzureCLIDeb | bash
  args:
    creates: /usr/bin/az
  become: true

- name: Crear script de backup 
  copy:
    dest: /usr/local/bin/db_backup.sh
    mode: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail

      TIMESTAMP=$(date +%Y%m%dT%H%M%S)
      BACKUP_FILE="/tmp/{{ db_name }}_$TIMESTAMP.sql.enc"
      LATEST_FILE="/tmp/{{ db_name }}_latest.sql.enc"

      # Crear backup cifrado
      mysqldump -u{{ db_user }} -p'{{ db_password }}' {{ db_name }} \
      | openssl enc -aes-256-cbc -salt -k '{{ backup_password }}' \
      > "$BACKUP_FILE"

      # Subir backup con timestamp
      az storage blob upload \
        --account-name {{ azure_storage_account }} \
        --account-key {{ azure_storage_key }} \
        --container-name {{ azure_container }} \
        --file "$BACKUP_FILE" \
        --name "$(basename "$BACKUP_FILE")" \
        --overwrite

      # Actualizar backup latest
      cp "$BACKUP_FILE" "$LATEST_FILE"
      az storage blob upload \
        --account-name {{ azure_storage_account }} \
        --account-key {{ azure_storage_key }} \
        --container-name {{ azure_container }} \
        --file "$LATEST_FILE" \
        --name "$(basename "$LATEST_FILE")" \
        --overwrite

      # Borrar archivos temporales
      rm -f "$BACKUP_FILE" "$LATEST_FILE"

- name: Programar backup diario a las 2 AM
  cron:
    name: "Backup diario MySQL a Azure"
    minute: "0"
    hour: "2"
    job: "/usr/local/bin/db_backup.sh"
    user: root

- name: Comprobar que el cron contiene la tarea
  shell: crontab -l | grep "/usr/local/bin/db_backup.sh"
  register: cron_check
  changed_when: false
  failed_when: cron_check.rc != 0

- name: Verificar que el cron se configur√≥ correctamente
  assert:
    that:
      - cron_check.rc == 0
    success_msg: "El cron para el backup diario est√° configurado correctamente."
    fail_msg: "El cron no se configur√≥ correctamente."
```

---

#### `roles/dr_test/tasks/main.yml`

Restaura la base de datos desde el √∫ltimo backup de Azure: instala Azure CLI, crea el directorio de restauraci√≥n, descarga y desencripta el backup, lo importa en MySQL y verifica que la base de datos responda correctamente.

```yml
- name: Instalar Azure CLI en la VM de base de datos
  shell: curl -sL https://aka.ms/InstallAzureCLIDeb | bash
  args:
    creates: /usr/bin/az
  become: true

- name: Crear directorio temporal para restauraci√≥n
  file:
    path: "{{ restore_dir }}"
    state: directory
    mode: '0755'

- name: Descargar el √∫ltimo backup desde Azure Storage
  shell: >
    az storage blob download
    --account-name {{ azure_storage_account }}
    --account-key {{ azure_storage_key }}
    --container-name {{ azure_container }}
    --name {{ db_name }}_latest.sql.enc
    --file {{ restore_dir }}/restore.sql.enc
  args:
    creates: "{{ restore_dir }}/restore.sql.enc"

- name: Desencriptar el backup
  command: >
    openssl enc -d -aes-256-cbc
    -in {{ restore_dir }}/restore.sql.enc
    -out {{ restore_dir }}/restore.sql
    -k "{{ backup_password }}"
  args:
    creates: "{{ restore_dir }}/restore.sql"

- name: Restaurar la base de datos desde el backup
  shell: >
    mysql -u{{ db_user }} -p'{{ db_password }}' {{ db_name }} < {{ restore_dir }}/restore.sql

- name: Validar restauraci√≥n de la base de datos
  shell: >
    mysql -u{{ db_user }} -p'{{ db_password }}' -D {{ db_name }} -e "SELECT 1;"
  register: db_validation
  changed_when: false

- name: Verificar que la base de datos responde correctamente
  assert:
    that:
      - "'1' in db_validation.stdout"
    success_msg: "La base de datos se restaur√≥ y responde correctamente."
    fail_msg: "La restauraci√≥n fall√≥: la base de datos no responde correctamente."
```

---

#### `roles/mysql/tasks/main.yml`

Instala y configura MySQL en la m√°quina de base de datos: instala el servidor y dependencias, crea la base de datos y el usuario de aplicaci√≥n con los privilegios necesarios, aplica la configuraci√≥n segura y verifica que la base de datos y el usuario existan correctamente.

```yml
- name: Instalar servidor MySQL
  apt:
    name: mysql-server
    state: present
    update_cache: yes

- name: Asegurar que MySQL est√° arrancado
  service:
    name: mysql
    state: started
    enabled: true

- name: Instalar dependencias Python para manejar MySQL
  apt:
    name: python3-pymysql
    state: present

- name: Crear base de datos
  community.mysql.mysql_db:
    name: "{{ db_name }}"
    state: present
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: Crear usuario de aplicaci√≥n
  community.mysql.mysql_user:
    name: "{{ db_user }}"
    password: "{{ db_password }}"
    priv: "{{ db_name }}.*:ALL"
    host: "%"
    state: present
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: Dar privilegios necesarios al usuario para backup
  community.mysql.mysql_user:
    name: "{{ db_user }}"
    host: "%"
    priv: "*.*:PROCESS,SELECT,LOCK TABLES,SHOW VIEW,EVENT,TRIGGER"
    state: present
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: Copiar configuraci√≥n segura de MySQL 
  template:
    src: mysqld.cnf.j2
    dest: /etc/mysql/mysql.conf.d/mysqld.cnf
    owner: root
    group: root
    mode: 0644
  notify: Reiniciar MySQL

- name: Verificar que la base de datos existe
  command: "mysql -uroot -e 'SHOW DATABASES LIKE \"{{ db_name }}\";'"
  register: db_check
  changed_when: false

- name: Mostrar el nombre de la base de datos
  debug:
    msg: "{{ db_check.stdout_lines[-1] }}"

- name: Verificar que el usuario existe
  command: "mysql -uroot -e 'SELECT User FROM mysql.user WHERE User=\"{{ db_user }}\";'"
  register: user_check
  changed_when: false

- name: Mostrar el nombre del usuario
  debug:
    msg: "{{ user_check.stdout_lines[-1] }}"
```

---

#### `roles/mysql/templates/mysqld.conf.j2`

Plantilla de configuraci√≥n de MySQL que define la direcci√≥n de enlace, el modo SQL y el n√∫mero m√°ximo de conexiones.

```ini
[mysqld]
bind-address = {{ mysql_bind_address }}
sql_mode=STRICT_ALL_TABLES
max_connections=200
```

---

#### `roles/mysql/handlers/main.yml`

Define un handler que reinicia el servicio de MySQL cuando se detectan cambios en la configuraci√≥n.

```yml
- name: Reiniciar MySQL
  service:
    name: mysql
    state: restarted
```

[üîù Volver a la tabla de contenidos üîù](#-tabla-de-contenidos) 

---

## ‚öôÔ∏è 4.6 Preparaci√≥n entorno Ansible

Antes de ejecutar los playbooks, es necesario preparar el entorno realizando algunos pasos previos para asegurar que todas las dependencias est√©n instaladas y que las variables sensibles est√©n protegidas. A continuaci√≥n se detallan estos pasos:

* Instalar requisitos:

    ```bash
    ansible-galaxy collection install -r requirements.yml
    ```

    > Se deben instalar las colecciones y dependencias indicadas en requirements.yml, por ejemplo la colecci√≥n community.mysql, para que los m√≥dulos necesarios para los playbooks est√©n disponibles.

* Configurar y cifrar variables sensibles:
  
    ```bash
    ansible-vault encrypt inventories/dev/group_vars/vault.yml
    ```

    > Esto cifra el archivo, impidiendo que los datos sensibles queden visibles en texto plano. Durante la ejecuci√≥n de los playbooks, Ansible puede desencriptar autom√°ticamente estas variables solicitando la contrase√±a con --ask-vault-pass, manteniendo la seguridad de la informaci√≥n.

* La clave `azure_storage_key` se consigue dentro del portal de Azure en la siguinete secci√≥n:

  ![](imgs/04/1.png)

---

## üöÄ 4.7 Lanzar playbooks 

Ahora que el entorno est√° preparado y las variables sensibles est√°n protegidas, se puede proceder a ejecutar los playbooks de Ansible. Esto incluye lanzar los roles correspondientes a cada m√°quina seg√∫n su funci√≥n, garantizando que la configuraci√≥n de bases de datos, backups y pruebas de Disaster Recovery se aplique correctamente en el entorno de desarrollo.

### ‚úÖ 4.7.1 Probar conexi√≥n

Antes de ejecutar cualquier playbook, lo primero que debemos comprobar es que Ansible puede conectarse correctamente a todas las m√°quinas definidas en el inventario. Esto nos asegura que los hosts est√°n accesibles y que la configuraci√≥n de usuario y clave SSH funciona correctamente, evitando errores durante la ejecuci√≥n de las tareas. Para realizar esta verificaci√≥n, usamos el m√≥dulo ping de Ansible con el siguiente comando:

```bash
ansible all -i inventories/dev/inventory.ini -m ping
```

---

### üõ†Ô∏è 4.7.2 Configuraci√≥n de MySQL en la VM de base de datos

Para lanzar este primer playbook basta con ejeuctar el siguiente comando e introducir la contrase√±a usada anteriormente para encriptar los datos que el playbook necesita:

```bash
ansible-playbook -i inventories/dev/inventory.ini playbooks/db.yml --ask-vault-pass
```

---

### üíæ 4.7.2 Automatizaci√≥n de backups de la BBDD

Hacemos lo mismo que la anterior pero esta vez con el archivo de backup:

```bash
ansible-playbook -i inventories/dev/inventory.ini playbooks/bkp.yml --ask-vault-pass
```

---

### üîÑ 4.7.3 Automatizaci√≥n de backups de la BBDD

Y ya por √∫ltimo probamos si funciona la restauraci√≥n de la base de datos seg√∫n el archivo backup subido al storage account:

```bash
ansible-playbook -i inventories/dev/inventory.ini playbooks/dr.yml --ask-vault-pass
```

[üîù Volver a la tabla de contenidos üîù](#-tabla-de-contenidos) 



























